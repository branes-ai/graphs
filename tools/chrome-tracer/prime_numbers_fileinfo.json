{
    "traceEvents": [
        {
            "ph": "M",
            "pid": 38284,
            "tid": 38284,
            "name": "process_name",
            "args": {
                "name": "MainProcess"
            }
        },
        {
            "ph": "M",
            "pid": 38284,
            "tid": 28788,
            "name": "thread_name",
            "args": {
                "name": "MainThread"
            }
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733002901.945,
            "ph": "X",
            "cat": "fee",
            "dur": 107.2,
            "name": "builtins.print"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003010.845,
            "ph": "X",
            "cat": "fee",
            "dur": 0.6,
            "name": "time.time"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003017.145,
            "ph": "X",
            "cat": "fee",
            "dur": 0.1,
            "name": "time.time"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003017.345,
            "ph": "X",
            "cat": "fee",
            "dur": 0.1,
            "name": "time.time"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003019.445,
            "ph": "X",
            "cat": "fee",
            "dur": 3.1,
            "name": "is_prime (C:\\Users\\tomtz\\dev\\branes\\clones\\graphs\\tools\\chrome-tracer\\prime_numbers.py:23)"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003023.045,
            "ph": "X",
            "cat": "fee",
            "dur": 0.1,
            "name": "time.time"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003024.245,
            "ph": "X",
            "cat": "fee",
            "dur": 9.6,
            "name": "time.gmtime"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003034.045,
            "ph": "X",
            "cat": "fee",
            "dur": 12.5,
            "name": "time.strftime"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003048.545,
            "ph": "X",
            "cat": "fee",
            "dur": 0.2,
            "name": "list.append"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003050.045,
            "ph": "X",
            "cat": "fee",
            "dur": 67.7,
            "name": "builtins.print"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003118.745,
            "ph": "X",
            "cat": "fee",
            "dur": 0.2,
            "name": "time.time"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003119.045,
            "ph": "X",
            "cat": "fee",
            "dur": 0.1,
            "name": "time.time"
        },
        {
            "pid": 38284,
            "tid": 28788,
            "ts": 370733003119.645,
            "ph": "X",
            "cat": "fee",
            "dur": 1.8,
            "name": "is_prime (C:\\Users\\tomtz\\dev\\branes\\clones\\graphs\\tools\\chrome-tracer\\prime_numbers.py:23)"
        }   
   ],
    "viztracer_metadata": {
        "overflow": false,
        "version": "1.0.4"
    },
    "file_info": {
        "files": {
            "C:\\Users\\tomtz\\dev\\branes\\clones\\graphs\\tools\\chrome-tracer\\prime_numbers.py": [
                "import json\nimport os\nimport time\n\n# Re-including the write function from the previous document for self-containment.\ndef write_viztracker_json(data: dict, file_path: str) -> None:\n    \"\"\"\n    Writes a dictionary to a JSON file in a format that can be consumed by Vizviewer.\n    The output is formatted for readability.\n\n    Args:\n        data: The dictionary containing the data to write.\n        file_path: The path to the output JSON file.\n    \"\"\"\n    try:\n        with open(file_path, 'w') as f:\n            json.dump(data, f, indent=4)\n        print(f\"Successfully wrote data to '{file_path}'.\")\n    except IOError as e:\n        print(f\"Error: Could not write to file '{file_path}'. Details: {e}\")\n        raise\n\ndef is_prime(n: int) -> bool:\n    \"\"\"\n    Checks if a number is prime using a simple trial division algorithm.\n    This is a compute-heavy function, especially for large 'n'.\n\n    Args:\n        n: The integer to check.\n\n    Returns:\n        True if the number is prime, False otherwise.\n    \"\"\"\n    # A prime number is a natural number greater than 1\n    if n <= 1:\n        return False\n    # Check for divisibility from 2 up to the square root of n\n    # This optimization reduces the number of checks significantly\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_primes(count: int) -> list:\n    \"\"\"\n    Finds a specified number of prime numbers and logs events for each one found.\n\n    Args:\n        count: The number of prime numbers to find.\n\n    Returns:\n        A list of event dictionaries, one for each prime found.\n    \"\"\"\n    prime_events = []\n    num_primes_found = 0\n    candidate_number = 2\n\n    while num_primes_found < count:\n        start_time = time.time()\n        \n        # This is the \"compute-heavy\" part we want to measure\n        prime_check_start_time = time.time()\n        if is_prime(candidate_number):\n            prime_check_end_time = time.time()\n            \n            num_primes_found += 1\n            \n            event_data = {\n                \"event_type\": \"prime_found\",\n                \"prime_number\": candidate_number,\n                \"prime_rank\": num_primes_found,\n                \"timestamp_utc\": time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),\n                \"duration_ms\": (prime_check_end_time - prime_check_start_time) * 1000\n            }\n            prime_events.append(event_data)\n            print(f\"Event {num_primes_found}: Found prime {candidate_number}\")\n\n        candidate_number += 1\n    \n    return prime_events\n\n# Main program execution\nif __name__ == \"__main__\":\n    NUMBER_OF_PRIMES_TO_FIND = 1000  # This will generate 1000 events\n    OUTPUT_FILENAME = \"prime_finder_viztracker_output.json\"\n\n    print(f\"Starting to find the first {NUMBER_OF_PRIMES_TO_FIND} prime numbers...\")\n    \n    start_total_time = time.time()\n    events = find_primes(NUMBER_OF_PRIMES_TO_FIND)\n    end_total_time = time.time()\n\n    total_duration_ms = (end_total_time - start_total_time) * 1000\n    print(f\"\\nFinished in {total_duration_ms:.2f} ms.\")\n    print(f\"Total events generated: {len(events)}\")\n    \n    viztracker_data = {\n        \"metadata\": {\n            \"source\": \"PrimeFinder\",\n            \"generation_time\": time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),\n            \"total_duration_ms\": total_duration_ms,\n            \"number_of_primes\": NUMBER_OF_PRIMES_TO_FIND\n        },\n        \"events\": events\n    }\n    \n    # Write the collected events to a JSON file\n    write_viztracker_json(viztracker_data, OUTPUT_FILENAME)\n",
                108
            ],
            "<frozen codecs>": [
                "\"\"\" codecs -- Python Codec Registry, API and helpers.\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.\n\n\"\"\"\n\nimport builtins\nimport sys\n\n### Registry and builtin stateless codec functions\n\ntry:\n    from _codecs import *\nexcept ImportError as why:\n    raise SystemError('Failed to load the builtin codecs: %s' % why)\n\n__all__ = [\"register\", \"lookup\", \"open\", \"EncodedFile\", \"BOM\", \"BOM_BE\",\n           \"BOM_LE\", \"BOM32_BE\", \"BOM32_LE\", \"BOM64_BE\", \"BOM64_LE\",\n           \"BOM_UTF8\", \"BOM_UTF16\", \"BOM_UTF16_LE\", \"BOM_UTF16_BE\",\n           \"BOM_UTF32\", \"BOM_UTF32_LE\", \"BOM_UTF32_BE\",\n           \"CodecInfo\", \"Codec\", \"IncrementalEncoder\", \"IncrementalDecoder\",\n           \"StreamReader\", \"StreamWriter\",\n           \"StreamReaderWriter\", \"StreamRecoder\",\n           \"getencoder\", \"getdecoder\", \"getincrementalencoder\",\n           \"getincrementaldecoder\", \"getreader\", \"getwriter\",\n           \"encode\", \"decode\", \"iterencode\", \"iterdecode\",\n           \"strict_errors\", \"ignore_errors\", \"replace_errors\",\n           \"xmlcharrefreplace_errors\",\n           \"backslashreplace_errors\", \"namereplace_errors\",\n           \"register_error\", \"lookup_error\"]\n\n### Constants\n\n#\n# Byte Order Mark (BOM = ZERO WIDTH NO-BREAK SPACE = U+FEFF)\n# and its possible byte string values\n# for UTF8/UTF16/UTF32 output and little/big endian machines\n#\n\n# UTF-8\nBOM_UTF8 = b'\\xef\\xbb\\xbf'\n\n# UTF-16, little endian\nBOM_LE = BOM_UTF16_LE = b'\\xff\\xfe'\n\n# UTF-16, big endian\nBOM_BE = BOM_UTF16_BE = b'\\xfe\\xff'\n\n# UTF-32, little endian\nBOM_UTF32_LE = b'\\xff\\xfe\\x00\\x00'\n\n# UTF-32, big endian\nBOM_UTF32_BE = b'\\x00\\x00\\xfe\\xff'\n\nif sys.byteorder == 'little':\n\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_LE\n\n    # UTF-32, native endianness\n    BOM_UTF32 = BOM_UTF32_LE\n\nelse:\n\n    # UTF-16, native endianness\n    BOM = BOM_UTF16 = BOM_UTF16_BE\n\n    # UTF-32, native endianness\n    BOM_UTF32 = BOM_UTF32_BE\n\n# Old broken names (don't use in new code)\nBOM32_LE = BOM_UTF16_LE\nBOM32_BE = BOM_UTF16_BE\nBOM64_LE = BOM_UTF32_LE\nBOM64_BE = BOM_UTF32_BE\n\n\n### Codec base classes (defining the API)\n\nclass CodecInfo(tuple):\n    \"\"\"Codec details when looking up the codec registry\"\"\"\n\n    # Private API to allow Python 3.4 to denylist the known non-Unicode\n    # codecs in the standard library. A more general mechanism to\n    # reliably distinguish test encodings from other codecs will hopefully\n    # be defined for Python 3.5\n    #\n    # See http://bugs.python.org/issue19619\n    _is_text_encoding = True # Assume codecs are text encodings by default\n\n    def __new__(cls, encode, decode, streamreader=None, streamwriter=None,\n        incrementalencoder=None, incrementaldecoder=None, name=None,\n        *, _is_text_encoding=None):\n        self = tuple.__new__(cls, (encode, decode, streamreader, streamwriter))\n        self.name = name\n        self.encode = encode\n        self.decode = decode\n        self.incrementalencoder = incrementalencoder\n        self.incrementaldecoder = incrementaldecoder\n        self.streamwriter = streamwriter\n        self.streamreader = streamreader\n        if _is_text_encoding is not None:\n            self._is_text_encoding = _is_text_encoding\n        return self\n\n    def __repr__(self):\n        return \"<%s.%s object for encoding %s at %#x>\" % \\\n                (self.__class__.__module__, self.__class__.__qualname__,\n                 self.name, id(self))\n\nclass Codec:\n\n    \"\"\" Defines the interface for stateless encoders/decoders.\n\n        The .encode()/.decode() methods may use different error\n        handling schemes by providing the errors argument. These\n        string values are predefined:\n\n         'strict' - raise a ValueError error (or a subclass)\n         'ignore' - ignore the character and continue with the next\n         'replace' - replace with a suitable replacement character;\n                    Python will use the official U+FFFD REPLACEMENT\n                    CHARACTER for the builtin Unicode codecs on\n                    decoding and '?' on encoding.\n         'surrogateescape' - replace with private code points U+DCnn.\n         'xmlcharrefreplace' - Replace with the appropriate XML\n                               character reference (only for encoding).\n         'backslashreplace'  - Replace with backslashed escape sequences.\n         'namereplace'       - Replace with \\\\N{...} escape sequences\n                               (only for encoding).\n\n        The set of allowed values can be extended via register_error.\n\n    \"\"\"\n    def encode(self, input, errors='strict'):\n\n        \"\"\" Encodes the object input and returns a tuple (output\n            object, length consumed).\n\n            errors defines the error handling to apply. It defaults to\n            'strict' handling.\n\n            The method may not store state in the Codec instance. Use\n            StreamWriter for codecs which have to keep state in order to\n            make encoding efficient.\n\n            The encoder must be able to handle zero length input and\n            return an empty object of the output object type in this\n            situation.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def decode(self, input, errors='strict'):\n\n        \"\"\" Decodes the object input and returns a tuple (output\n            object, length consumed).\n\n            input must be an object which provides the bf_getreadbuf\n            buffer slot. Python strings, buffer objects and memory\n            mapped files are examples of objects providing this slot.\n\n            errors defines the error handling to apply. It defaults to\n            'strict' handling.\n\n            The method may not store state in the Codec instance. Use\n            StreamReader for codecs which have to keep state in order to\n            make decoding efficient.\n\n            The decoder must be able to handle zero length input and\n            return an empty object of the output object type in this\n            situation.\n\n        \"\"\"\n        raise NotImplementedError\n\nclass IncrementalEncoder(object):\n    \"\"\"\n    An IncrementalEncoder encodes an input in multiple steps. The input can\n    be passed piece by piece to the encode() method. The IncrementalEncoder\n    remembers the state of the encoding process between calls to encode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        \"\"\"\n        Creates an IncrementalEncoder instance.\n\n        The IncrementalEncoder may use different error handling schemes by\n        providing the errors keyword argument. See the module docstring\n        for a list of possible values.\n        \"\"\"\n        self.errors = errors\n        self.buffer = \"\"\n\n    def encode(self, input, final=False):\n        \"\"\"\n        Encodes input and returns the resulting object.\n        \"\"\"\n        raise NotImplementedError\n\n    def reset(self):\n        \"\"\"\n        Resets the encoder to the initial state.\n        \"\"\"\n\n    def getstate(self):\n        \"\"\"\n        Return the current state of the encoder.\n        \"\"\"\n        return 0\n\n    def setstate(self, state):\n        \"\"\"\n        Set the current state of the encoder. state must have been\n        returned by getstate().\n        \"\"\"\n\nclass BufferedIncrementalEncoder(IncrementalEncoder):\n    \"\"\"\n    This subclass of IncrementalEncoder can be used as the baseclass for an\n    incremental encoder if the encoder must keep some of the output in a\n    buffer between calls to encode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        IncrementalEncoder.__init__(self, errors)\n        # unencoded input that is kept between calls to encode()\n        self.buffer = \"\"\n\n    def _buffer_encode(self, input, errors, final):\n        # Overwrite this method in subclasses: It must encode input\n        # and return an (output, length consumed) tuple\n        raise NotImplementedError\n\n    def encode(self, input, final=False):\n        # encode input (taking the buffer into account)\n        data = self.buffer + input\n        (result, consumed) = self._buffer_encode(data, self.errors, final)\n        # keep unencoded input until the next call\n        self.buffer = data[consumed:]\n        return result\n\n    def reset(self):\n        IncrementalEncoder.reset(self)\n        self.buffer = \"\"\n\n    def getstate(self):\n        return self.buffer or 0\n\n    def setstate(self, state):\n        self.buffer = state or \"\"\n\nclass IncrementalDecoder(object):\n    \"\"\"\n    An IncrementalDecoder decodes an input in multiple steps. The input can\n    be passed piece by piece to the decode() method. The IncrementalDecoder\n    remembers the state of the decoding process between calls to decode().\n    \"\"\"\n    def __init__(self, errors='strict'):\n        \"\"\"\n        Create an IncrementalDecoder instance.\n\n        The IncrementalDecoder may use different error handling schemes by\n        providing the errors keyword argument. See the module docstring\n        for a list of possible values.\n        \"\"\"\n        self.errors = errors\n\n    def decode(self, input, final=False):\n        \"\"\"\n        Decode input and returns the resulting object.\n        \"\"\"\n        raise NotImplementedError\n\n    def reset(self):\n        \"\"\"\n        Reset the decoder to the initial state.\n        \"\"\"\n\n    def getstate(self):\n        \"\"\"\n        Return the current state of the decoder.\n\n        This must be a (buffered_input, additional_state_info) tuple.\n        buffered_input must be a bytes object containing bytes that\n        were passed to decode() that have not yet been converted.\n        additional_state_info must be a non-negative integer\n        representing the state of the decoder WITHOUT yet having\n        processed the contents of buffered_input.  In the initial state\n        and after reset(), getstate() must return (b\"\", 0).\n        \"\"\"\n        return (b\"\", 0)\n\n    def setstate(self, state):\n        \"\"\"\n        Set the current state of the decoder.\n\n        state must have been returned by getstate().  The effect of\n        setstate((b\"\", 0)) must be equivalent to reset().\n        \"\"\"\n\nclass BufferedIncrementalDecoder(IncrementalDecoder):\n    \"\"\"\n    This subclass of IncrementalDecoder can be used as the baseclass for an\n    incremental decoder if the decoder must be able to handle incomplete\n    byte sequences.\n    \"\"\"\n    def __init__(self, errors='strict'):\n        IncrementalDecoder.__init__(self, errors)\n        # undecoded input that is kept between calls to decode()\n        self.buffer = b\"\"\n\n    def _buffer_decode(self, input, errors, final):\n        # Overwrite this method in subclasses: It must decode input\n        # and return an (output, length consumed) tuple\n        raise NotImplementedError\n\n    def decode(self, input, final=False):\n        # decode input (taking the buffer into account)\n        data = self.buffer + input\n        (result, consumed) = self._buffer_decode(data, self.errors, final)\n        # keep undecoded input until the next call\n        self.buffer = data[consumed:]\n        return result\n\n    def reset(self):\n        IncrementalDecoder.reset(self)\n        self.buffer = b\"\"\n\n    def getstate(self):\n        # additional state info is always 0\n        return (self.buffer, 0)\n\n    def setstate(self, state):\n        # ignore additional state info\n        self.buffer = state[0]\n\n#\n# The StreamWriter and StreamReader class provide generic working\n# interfaces which can be used to implement new encoding submodules\n# very easily. See encodings/utf_8.py for an example on how this is\n# done.\n#\n\nclass StreamWriter(Codec):\n\n    def __init__(self, stream, errors='strict'):\n\n        \"\"\" Creates a StreamWriter instance.\n\n            stream must be a file-like object open for writing.\n\n            The StreamWriter may use different error handling\n            schemes by providing the errors keyword argument. These\n            parameters are predefined:\n\n             'strict' - raise a ValueError (or a subclass)\n             'ignore' - ignore the character and continue with the next\n             'replace'- replace with a suitable replacement character\n             'xmlcharrefreplace' - Replace with the appropriate XML\n                                   character reference.\n             'backslashreplace'  - Replace with backslashed escape\n                                   sequences.\n             'namereplace'       - Replace with \\\\N{...} escape sequences.\n\n            The set of allowed parameter values can be extended via\n            register_error.\n        \"\"\"\n        self.stream = stream\n        self.errors = errors\n\n    def write(self, object):\n\n        \"\"\" Writes the object's contents encoded to self.stream.\n        \"\"\"\n        data, consumed = self.encode(object, self.errors)\n        self.stream.write(data)\n\n    def writelines(self, list):\n\n        \"\"\" Writes the concatenated list of strings to the stream\n            using .write().\n        \"\"\"\n        self.write(''.join(list))\n\n    def reset(self):\n\n        \"\"\" Resets the codec buffers used for keeping internal state.\n\n            Calling this method should ensure that the data on the\n            output is put into a clean state, that allows appending\n            of new fresh data without having to rescan the whole\n            stream to recover state.\n\n        \"\"\"\n        pass\n\n    def seek(self, offset, whence=0):\n        self.stream.seek(offset, whence)\n        if whence == 0 and offset == 0:\n            self.reset()\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n    def __reduce_ex__(self, proto):\n        raise TypeError(\"can't serialize %s\" % self.__class__.__name__)\n\n###\n\nclass StreamReader(Codec):\n\n    charbuffertype = str\n\n    def __init__(self, stream, errors='strict'):\n\n        \"\"\" Creates a StreamReader instance.\n\n            stream must be a file-like object open for reading.\n\n            The StreamReader may use different error handling\n            schemes by providing the errors keyword argument. These\n            parameters are predefined:\n\n             'strict' - raise a ValueError (or a subclass)\n             'ignore' - ignore the character and continue with the next\n             'replace'- replace with a suitable replacement character\n             'backslashreplace' - Replace with backslashed escape sequences;\n\n            The set of allowed parameter values can be extended via\n            register_error.\n        \"\"\"\n        self.stream = stream\n        self.errors = errors\n        self.bytebuffer = b\"\"\n        self._empty_charbuffer = self.charbuffertype()\n        self.charbuffer = self._empty_charbuffer\n        self.linebuffer = None\n\n    def decode(self, input, errors='strict'):\n        raise NotImplementedError\n\n    def read(self, size=-1, chars=-1, firstline=False):\n\n        \"\"\" Decodes data from the stream self.stream and returns the\n            resulting object.\n\n            chars indicates the number of decoded code points or bytes to\n            return. read() will never return more data than requested,\n            but it might return less, if there is not enough available.\n\n            size indicates the approximate maximum number of decoded\n            bytes or code points to read for decoding. The decoder\n            can modify this setting as appropriate. The default value\n            -1 indicates to read and decode as much as possible.  size\n            is intended to prevent having to decode huge files in one\n            step.\n\n            If firstline is true, and a UnicodeDecodeError happens\n            after the first line terminator in the input only the first line\n            will be returned, the rest of the input will be kept until the\n            next call to read().\n\n            The method should use a greedy read strategy, meaning that\n            it should read as much data as is allowed within the\n            definition of the encoding and the given size, e.g.  if\n            optional encoding endings or state markers are available\n            on the stream, these should be read too.\n        \"\"\"\n        # If we have lines cached, first merge them back into characters\n        if self.linebuffer:\n            self.charbuffer = self._empty_charbuffer.join(self.linebuffer)\n            self.linebuffer = None\n\n        if chars < 0:\n            # For compatibility with other read() methods that take a\n            # single argument\n            chars = size\n\n        # read until we get the required number of characters (if available)\n        while True:\n            # can the request be satisfied from the character buffer?\n            if chars >= 0:\n                if len(self.charbuffer) >= chars:\n                    break\n            # we need more data\n            if size < 0:\n                newdata = self.stream.read()\n            else:\n                newdata = self.stream.read(size)\n            # decode bytes (those remaining from the last call included)\n            data = self.bytebuffer + newdata\n            if not data:\n                break\n            try:\n                newchars, decodedbytes = self.decode(data, self.errors)\n            except UnicodeDecodeError as exc:\n                if firstline:\n                    newchars, decodedbytes = \\\n                        self.decode(data[:exc.start], self.errors)\n                    lines = newchars.splitlines(keepends=True)\n                    if len(lines)<=1:\n                        raise\n                else:\n                    raise\n            # keep undecoded bytes until the next call\n            self.bytebuffer = data[decodedbytes:]\n            # put new characters in the character buffer\n            self.charbuffer += newchars\n            # there was no data available\n            if not newdata:\n                break\n        if chars < 0:\n            # Return everything we've got\n            result = self.charbuffer\n            self.charbuffer = self._empty_charbuffer\n        else:\n            # Return the first chars characters\n            result = self.charbuffer[:chars]\n            self.charbuffer = self.charbuffer[chars:]\n        return result\n\n    def readline(self, size=None, keepends=True):\n\n        \"\"\" Read one line from the input stream and return the\n            decoded data.\n\n            size, if given, is passed as size argument to the\n            read() method.\n\n        \"\"\"\n        # If we have lines cached from an earlier read, return\n        # them unconditionally\n        if self.linebuffer:\n            line = self.linebuffer[0]\n            del self.linebuffer[0]\n            if len(self.linebuffer) == 1:\n                # revert to charbuffer mode; we might need more data\n                # next time\n                self.charbuffer = self.linebuffer[0]\n                self.linebuffer = None\n            if not keepends:\n                line = line.splitlines(keepends=False)[0]\n            return line\n\n        readsize = size or 72\n        line = self._empty_charbuffer\n        # If size is given, we call read() only once\n        while True:\n            data = self.read(readsize, firstline=True)\n            if data:\n                # If we're at a \"\\r\" read one extra character (which might\n                # be a \"\\n\") to get a proper line ending. If the stream is\n                # temporarily exhausted we return the wrong line ending.\n                if (isinstance(data, str) and data.endswith(\"\\r\")) or \\\n                   (isinstance(data, bytes) and data.endswith(b\"\\r\")):\n                    data += self.read(size=1, chars=1)\n\n            line += data\n            lines = line.splitlines(keepends=True)\n            if lines:\n                if len(lines) > 1:\n                    # More than one line result; the first line is a full line\n                    # to return\n                    line = lines[0]\n                    del lines[0]\n                    if len(lines) > 1:\n                        # cache the remaining lines\n                        lines[-1] += self.charbuffer\n                        self.linebuffer = lines\n                        self.charbuffer = None\n                    else:\n                        # only one remaining line, put it back into charbuffer\n                        self.charbuffer = lines[0] + self.charbuffer\n                    if not keepends:\n                        line = line.splitlines(keepends=False)[0]\n                    break\n                line0withend = lines[0]\n                line0withoutend = lines[0].splitlines(keepends=False)[0]\n                if line0withend != line0withoutend: # We really have a line end\n                    # Put the rest back together and keep it until the next call\n                    self.charbuffer = self._empty_charbuffer.join(lines[1:]) + \\\n                                      self.charbuffer\n                    if keepends:\n                        line = line0withend\n                    else:\n                        line = line0withoutend\n                    break\n            # we didn't get anything or this was our only try\n            if not data or size is not None:\n                if line and not keepends:\n                    line = line.splitlines(keepends=False)[0]\n                break\n            if readsize < 8000:\n                readsize *= 2\n        return line\n\n    def readlines(self, sizehint=None, keepends=True):\n\n        \"\"\" Read all lines available on the input stream\n            and return them as a list.\n\n            Line breaks are implemented using the codec's decoder\n            method and are included in the list entries.\n\n            sizehint, if given, is ignored since there is no efficient\n            way to finding the true end-of-line.\n\n        \"\"\"\n        data = self.read()\n        return data.splitlines(keepends)\n\n    def reset(self):\n\n        \"\"\" Resets the codec buffers used for keeping internal state.\n\n            Note that no stream repositioning should take place.\n            This method is primarily intended to be able to recover\n            from decoding errors.\n\n        \"\"\"\n        self.bytebuffer = b\"\"\n        self.charbuffer = self._empty_charbuffer\n        self.linebuffer = None\n\n    def seek(self, offset, whence=0):\n        \"\"\" Set the input stream's current position.\n\n            Resets the codec buffers used for keeping state.\n        \"\"\"\n        self.stream.seek(offset, whence)\n        self.reset()\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        line = self.readline()\n        if line:\n            return line\n        raise StopIteration\n\n    def __iter__(self):\n        return self\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n    def __reduce_ex__(self, proto):\n        raise TypeError(\"can't serialize %s\" % self.__class__.__name__)\n\n###\n\nclass StreamReaderWriter:\n\n    \"\"\" StreamReaderWriter instances allow wrapping streams which\n        work in both read and write modes.\n\n        The design is such that one can use the factory functions\n        returned by the codec.lookup() function to construct the\n        instance.\n\n    \"\"\"\n    # Optional attributes set by the file wrappers below\n    encoding = 'unknown'\n\n    def __init__(self, stream, Reader, Writer, errors='strict'):\n\n        \"\"\" Creates a StreamReaderWriter instance.\n\n            stream must be a Stream-like object.\n\n            Reader, Writer must be factory functions or classes\n            providing the StreamReader, StreamWriter interface resp.\n\n            Error handling is done in the same way as defined for the\n            StreamWriter/Readers.\n\n        \"\"\"\n        self.stream = stream\n        self.reader = Reader(stream, errors)\n        self.writer = Writer(stream, errors)\n        self.errors = errors\n\n    def read(self, size=-1):\n\n        return self.reader.read(size)\n\n    def readline(self, size=None):\n\n        return self.reader.readline(size)\n\n    def readlines(self, sizehint=None):\n\n        return self.reader.readlines(sizehint)\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        return next(self.reader)\n\n    def __iter__(self):\n        return self\n\n    def write(self, data):\n\n        return self.writer.write(data)\n\n    def writelines(self, list):\n\n        return self.writer.writelines(list)\n\n    def reset(self):\n\n        self.reader.reset()\n        self.writer.reset()\n\n    def seek(self, offset, whence=0):\n        self.stream.seek(offset, whence)\n        self.reader.reset()\n        if whence == 0 and offset == 0:\n            self.writer.reset()\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    # these are needed to make \"with StreamReaderWriter(...)\" work properly\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n    def __reduce_ex__(self, proto):\n        raise TypeError(\"can't serialize %s\" % self.__class__.__name__)\n\n###\n\nclass StreamRecoder:\n\n    \"\"\" StreamRecoder instances translate data from one encoding to another.\n\n        They use the complete set of APIs returned by the\n        codecs.lookup() function to implement their task.\n\n        Data written to the StreamRecoder is first decoded into an\n        intermediate format (depending on the \"decode\" codec) and then\n        written to the underlying stream using an instance of the provided\n        Writer class.\n\n        In the other direction, data is read from the underlying stream using\n        a Reader instance and then encoded and returned to the caller.\n\n    \"\"\"\n    # Optional attributes set by the file wrappers below\n    data_encoding = 'unknown'\n    file_encoding = 'unknown'\n\n    def __init__(self, stream, encode, decode, Reader, Writer,\n                 errors='strict'):\n\n        \"\"\" Creates a StreamRecoder instance which implements a two-way\n            conversion: encode and decode work on the frontend (the\n            data visible to .read() and .write()) while Reader and Writer\n            work on the backend (the data in stream).\n\n            You can use these objects to do transparent\n            transcodings from e.g. latin-1 to utf-8 and back.\n\n            stream must be a file-like object.\n\n            encode and decode must adhere to the Codec interface; Reader and\n            Writer must be factory functions or classes providing the\n            StreamReader and StreamWriter interfaces resp.\n\n            Error handling is done in the same way as defined for the\n            StreamWriter/Readers.\n\n        \"\"\"\n        self.stream = stream\n        self.encode = encode\n        self.decode = decode\n        self.reader = Reader(stream, errors)\n        self.writer = Writer(stream, errors)\n        self.errors = errors\n\n    def read(self, size=-1):\n\n        data = self.reader.read(size)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def readline(self, size=None):\n\n        if size is None:\n            data = self.reader.readline()\n        else:\n            data = self.reader.readline(size)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def readlines(self, sizehint=None):\n\n        data = self.reader.read()\n        data, bytesencoded = self.encode(data, self.errors)\n        return data.splitlines(keepends=True)\n\n    def __next__(self):\n\n        \"\"\" Return the next decoded line from the input stream.\"\"\"\n        data = next(self.reader)\n        data, bytesencoded = self.encode(data, self.errors)\n        return data\n\n    def __iter__(self):\n        return self\n\n    def write(self, data):\n\n        data, bytesdecoded = self.decode(data, self.errors)\n        return self.writer.write(data)\n\n    def writelines(self, list):\n\n        data = b''.join(list)\n        data, bytesdecoded = self.decode(data, self.errors)\n        return self.writer.write(data)\n\n    def reset(self):\n\n        self.reader.reset()\n        self.writer.reset()\n\n    def seek(self, offset, whence=0):\n        # Seeks must be propagated to both the readers and writers\n        # as they might need to reset their internal buffers.\n        self.reader.seek(offset, whence)\n        self.writer.seek(offset, whence)\n\n    def __getattr__(self, name,\n                    getattr=getattr):\n\n        \"\"\" Inherit all other methods from the underlying stream.\n        \"\"\"\n        return getattr(self.stream, name)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, tb):\n        self.stream.close()\n\n    def __reduce_ex__(self, proto):\n        raise TypeError(\"can't serialize %s\" % self.__class__.__name__)\n\n### Shortcuts\n\ndef open(filename, mode='r', encoding=None, errors='strict', buffering=-1):\n\n    \"\"\" Open an encoded file using the given mode and return\n        a wrapped version providing transparent encoding/decoding.\n\n        Note: The wrapped version will only accept the object format\n        defined by the codecs, i.e. Unicode objects for most builtin\n        codecs. Output is also codec dependent and will usually be\n        Unicode as well.\n\n        If encoding is not None, then the\n        underlying encoded files are always opened in binary mode.\n        The default file mode is 'r', meaning to open the file in read mode.\n\n        encoding specifies the encoding which is to be used for the\n        file.\n\n        errors may be given to define the error handling. It defaults\n        to 'strict' which causes ValueErrors to be raised in case an\n        encoding error occurs.\n\n        buffering has the same meaning as for the builtin open() API.\n        It defaults to -1 which means that the default buffer size will\n        be used.\n\n        The returned wrapped file object provides an extra attribute\n        .encoding which allows querying the used encoding. This\n        attribute is only available if an encoding was specified as\n        parameter.\n\n    \"\"\"\n    if encoding is not None and \\\n       'b' not in mode:\n        # Force opening of the file in binary mode\n        mode = mode + 'b'\n    file = builtins.open(filename, mode, buffering)\n    if encoding is None:\n        return file\n\n    try:\n        info = lookup(encoding)\n        srw = StreamReaderWriter(file, info.streamreader, info.streamwriter, errors)\n        # Add attributes to simplify introspection\n        srw.encoding = encoding\n        return srw\n    except:\n        file.close()\n        raise\n\ndef EncodedFile(file, data_encoding, file_encoding=None, errors='strict'):\n\n    \"\"\" Return a wrapped version of file which provides transparent\n        encoding translation.\n\n        Data written to the wrapped file is decoded according\n        to the given data_encoding and then encoded to the underlying\n        file using file_encoding. The intermediate data type\n        will usually be Unicode but depends on the specified codecs.\n\n        Bytes read from the file are decoded using file_encoding and then\n        passed back to the caller encoded using data_encoding.\n\n        If file_encoding is not given, it defaults to data_encoding.\n\n        errors may be given to define the error handling. It defaults\n        to 'strict' which causes ValueErrors to be raised in case an\n        encoding error occurs.\n\n        The returned wrapped file object provides two extra attributes\n        .data_encoding and .file_encoding which reflect the given\n        parameters of the same name. The attributes can be used for\n        introspection by Python programs.\n\n    \"\"\"\n    if file_encoding is None:\n        file_encoding = data_encoding\n    data_info = lookup(data_encoding)\n    file_info = lookup(file_encoding)\n    sr = StreamRecoder(file, data_info.encode, data_info.decode,\n                       file_info.streamreader, file_info.streamwriter, errors)\n    # Add attributes to simplify introspection\n    sr.data_encoding = data_encoding\n    sr.file_encoding = file_encoding\n    return sr\n\n### Helpers for codec lookup\n\ndef getencoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its encoder function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).encode\n\ndef getdecoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its decoder function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).decode\n\ndef getincrementalencoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its IncrementalEncoder class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found\n        or the codecs doesn't provide an incremental encoder.\n\n    \"\"\"\n    encoder = lookup(encoding).incrementalencoder\n    if encoder is None:\n        raise LookupError(encoding)\n    return encoder\n\ndef getincrementaldecoder(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its IncrementalDecoder class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found\n        or the codecs doesn't provide an incremental decoder.\n\n    \"\"\"\n    decoder = lookup(encoding).incrementaldecoder\n    if decoder is None:\n        raise LookupError(encoding)\n    return decoder\n\ndef getreader(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its StreamReader class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).streamreader\n\ndef getwriter(encoding):\n\n    \"\"\" Lookup up the codec for the given encoding and return\n        its StreamWriter class or factory function.\n\n        Raises a LookupError in case the encoding cannot be found.\n\n    \"\"\"\n    return lookup(encoding).streamwriter\n\ndef iterencode(iterator, encoding, errors='strict', **kwargs):\n    \"\"\"\n    Encoding iterator.\n\n    Encodes the input strings from the iterator using an IncrementalEncoder.\n\n    errors and kwargs are passed through to the IncrementalEncoder\n    constructor.\n    \"\"\"\n    encoder = getincrementalencoder(encoding)(errors, **kwargs)\n    for input in iterator:\n        output = encoder.encode(input)\n        if output:\n            yield output\n    output = encoder.encode(\"\", True)\n    if output:\n        yield output\n\ndef iterdecode(iterator, encoding, errors='strict', **kwargs):\n    \"\"\"\n    Decoding iterator.\n\n    Decodes the input strings from the iterator using an IncrementalDecoder.\n\n    errors and kwargs are passed through to the IncrementalDecoder\n    constructor.\n    \"\"\"\n    decoder = getincrementaldecoder(encoding)(errors, **kwargs)\n    for input in iterator:\n        output = decoder.decode(input)\n        if output:\n            yield output\n    output = decoder.decode(b\"\", True)\n    if output:\n        yield output\n\n### Helpers for charmap-based codecs\n\ndef make_identity_dict(rng):\n\n    \"\"\" make_identity_dict(rng) -> dict\n\n        Return a dictionary where elements of the rng sequence are\n        mapped to themselves.\n\n    \"\"\"\n    return {i:i for i in rng}\n\ndef make_encoding_map(decoding_map):\n\n    \"\"\" Creates an encoding map from a decoding map.\n\n        If a target mapping in the decoding map occurs multiple\n        times, then that target is mapped to None (undefined mapping),\n        causing an exception when encountered by the charmap codec\n        during translation.\n\n        One example where this happens is cp875.py which decodes\n        multiple character to \\\\u001a.\n\n    \"\"\"\n    m = {}\n    for k,v in decoding_map.items():\n        if not v in m:\n            m[v] = k\n        else:\n            m[v] = None\n    return m\n\n### error handlers\n\ntry:\n    strict_errors = lookup_error(\"strict\")\n    ignore_errors = lookup_error(\"ignore\")\n    replace_errors = lookup_error(\"replace\")\n    xmlcharrefreplace_errors = lookup_error(\"xmlcharrefreplace\")\n    backslashreplace_errors = lookup_error(\"backslashreplace\")\n    namereplace_errors = lookup_error(\"namereplace\")\nexcept LookupError:\n    # In --disable-unicode builds, these error handler are missing\n    strict_errors = None\n    ignore_errors = None\n    replace_errors = None\n    xmlcharrefreplace_errors = None\n    backslashreplace_errors = None\n    namereplace_errors = None\n\n# Tell modulefinder that using codecs probably needs the encodings\n# package\n_false = 0\nif _false:\n    import encodings\n\n### Tests\n\nif __name__ == '__main__':\n\n    # Make stdout translate Latin-1 output into UTF-8 output\n    sys.stdout = EncodedFile(sys.stdout, 'latin-1', 'utf-8')\n\n    # Have stdin translate Latin-1 input into UTF-8 input\n    sys.stdin = EncodedFile(sys.stdin, 'utf-8', 'latin-1')\n",
                1139
            ],
            "C:\\Python\\Python311\\Lib\\json\\encoder.py": [
                "\"\"\"Implementation of JSONEncoder\n\"\"\"\nimport re\n\ntry:\n    from _json import encode_basestring_ascii as c_encode_basestring_ascii\nexcept ImportError:\n    c_encode_basestring_ascii = None\ntry:\n    from _json import encode_basestring as c_encode_basestring\nexcept ImportError:\n    c_encode_basestring = None\ntry:\n    from _json import make_encoder as c_make_encoder\nexcept ImportError:\n    c_make_encoder = None\n\nESCAPE = re.compile(r'[\\x00-\\x1f\\\\\"\\b\\f\\n\\r\\t]')\nESCAPE_ASCII = re.compile(r'([\\\\\"]|[^\\ -~])')\nHAS_UTF8 = re.compile(b'[\\x80-\\xff]')\nESCAPE_DCT = {\n    '\\\\': '\\\\\\\\',\n    '\"': '\\\\\"',\n    '\\b': '\\\\b',\n    '\\f': '\\\\f',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\t': '\\\\t',\n}\nfor i in range(0x20):\n    ESCAPE_DCT.setdefault(chr(i), '\\\\u{0:04x}'.format(i))\n    #ESCAPE_DCT.setdefault(chr(i), '\\\\u%04x' % (i,))\ndel i\n\nINFINITY = float('inf')\n\ndef py_encode_basestring(s):\n    \"\"\"Return a JSON representation of a Python string\n\n    \"\"\"\n    def replace(match):\n        return ESCAPE_DCT[match.group(0)]\n    return '\"' + ESCAPE.sub(replace, s) + '\"'\n\n\nencode_basestring = (c_encode_basestring or py_encode_basestring)\n\n\ndef py_encode_basestring_ascii(s):\n    \"\"\"Return an ASCII-only JSON representation of a Python string\n\n    \"\"\"\n    def replace(match):\n        s = match.group(0)\n        try:\n            return ESCAPE_DCT[s]\n        except KeyError:\n            n = ord(s)\n            if n < 0x10000:\n                return '\\\\u{0:04x}'.format(n)\n                #return '\\\\u%04x' % (n,)\n            else:\n                # surrogate pair\n                n -= 0x10000\n                s1 = 0xd800 | ((n >> 10) & 0x3ff)\n                s2 = 0xdc00 | (n & 0x3ff)\n                return '\\\\u{0:04x}\\\\u{1:04x}'.format(s1, s2)\n    return '\"' + ESCAPE_ASCII.sub(replace, s) + '\"'\n\n\nencode_basestring_ascii = (\n    c_encode_basestring_ascii or py_encode_basestring_ascii)\n\nclass JSONEncoder(object):\n    \"\"\"Extensible JSON <https://json.org> encoder for Python data structures.\n\n    Supports the following objects and types by default:\n\n    +-------------------+---------------+\n    | Python            | JSON          |\n    +===================+===============+\n    | dict              | object        |\n    +-------------------+---------------+\n    | list, tuple       | array         |\n    +-------------------+---------------+\n    | str               | string        |\n    +-------------------+---------------+\n    | int, float        | number        |\n    +-------------------+---------------+\n    | True              | true          |\n    +-------------------+---------------+\n    | False             | false         |\n    +-------------------+---------------+\n    | None              | null          |\n    +-------------------+---------------+\n\n    To extend this to recognize other objects, subclass and implement a\n    ``.default()`` method with another method that returns a serializable\n    object for ``o`` if possible, otherwise it should call the superclass\n    implementation (to raise ``TypeError``).\n\n    \"\"\"\n    item_separator = ', '\n    key_separator = ': '\n    def __init__(self, *, skipkeys=False, ensure_ascii=True,\n            check_circular=True, allow_nan=True, sort_keys=False,\n            indent=None, separators=None, default=None):\n        \"\"\"Constructor for JSONEncoder, with sensible defaults.\n\n        If skipkeys is false, then it is a TypeError to attempt\n        encoding of keys that are not str, int, float or None.  If\n        skipkeys is True, such items are simply skipped.\n\n        If ensure_ascii is true, the output is guaranteed to be str\n        objects with all incoming non-ASCII characters escaped.  If\n        ensure_ascii is false, the output can contain non-ASCII characters.\n\n        If check_circular is true, then lists, dicts, and custom encoded\n        objects will be checked for circular references during encoding to\n        prevent an infinite recursion (which would cause an RecursionError).\n        Otherwise, no such check takes place.\n\n        If allow_nan is true, then NaN, Infinity, and -Infinity will be\n        encoded as such.  This behavior is not JSON specification compliant,\n        but is consistent with most JavaScript based encoders and decoders.\n        Otherwise, it will be a ValueError to encode such floats.\n\n        If sort_keys is true, then the output of dictionaries will be\n        sorted by key; this is useful for regression tests to ensure\n        that JSON serializations can be compared on a day-to-day basis.\n\n        If indent is a non-negative integer, then JSON array\n        elements and object members will be pretty-printed with that\n        indent level.  An indent level of 0 will only insert newlines.\n        None is the most compact representation.\n\n        If specified, separators should be an (item_separator, key_separator)\n        tuple.  The default is (', ', ': ') if *indent* is ``None`` and\n        (',', ': ') otherwise.  To get the most compact JSON representation,\n        you should specify (',', ':') to eliminate whitespace.\n\n        If specified, default is a function that gets called for objects\n        that can't otherwise be serialized.  It should return a JSON encodable\n        version of the object or raise a ``TypeError``.\n\n        \"\"\"\n\n        self.skipkeys = skipkeys\n        self.ensure_ascii = ensure_ascii\n        self.check_circular = check_circular\n        self.allow_nan = allow_nan\n        self.sort_keys = sort_keys\n        self.indent = indent\n        if separators is not None:\n            self.item_separator, self.key_separator = separators\n        elif indent is not None:\n            self.item_separator = ','\n        if default is not None:\n            self.default = default\n\n    def default(self, o):\n        \"\"\"Implement this method in a subclass such that it returns\n        a serializable object for ``o``, or calls the base implementation\n        (to raise a ``TypeError``).\n\n        For example, to support arbitrary iterators, you could\n        implement default like this::\n\n            def default(self, o):\n                try:\n                    iterable = iter(o)\n                except TypeError:\n                    pass\n                else:\n                    return list(iterable)\n                # Let the base class default method raise the TypeError\n                return super().default(o)\n\n        \"\"\"\n        raise TypeError(f'Object of type {o.__class__.__name__} '\n                        f'is not JSON serializable')\n\n    def encode(self, o):\n        \"\"\"Return a JSON string representation of a Python data structure.\n\n        >>> from json.encoder import JSONEncoder\n        >>> JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n        '{\"foo\": [\"bar\", \"baz\"]}'\n\n        \"\"\"\n        # This is for extremely simple cases and benchmarks.\n        if isinstance(o, str):\n            if self.ensure_ascii:\n                return encode_basestring_ascii(o)\n            else:\n                return encode_basestring(o)\n        # This doesn't pass the iterator directly to ''.join() because the\n        # exceptions aren't as detailed.  The list call should be roughly\n        # equivalent to the PySequence_Fast that ''.join() would do.\n        chunks = self.iterencode(o, _one_shot=True)\n        if not isinstance(chunks, (list, tuple)):\n            chunks = list(chunks)\n        return ''.join(chunks)\n\n    def iterencode(self, o, _one_shot=False):\n        \"\"\"Encode the given object and yield each string\n        representation as available.\n\n        For example::\n\n            for chunk in JSONEncoder().iterencode(bigobject):\n                mysocket.write(chunk)\n\n        \"\"\"\n        if self.check_circular:\n            markers = {}\n        else:\n            markers = None\n        if self.ensure_ascii:\n            _encoder = encode_basestring_ascii\n        else:\n            _encoder = encode_basestring\n\n        def floatstr(o, allow_nan=self.allow_nan,\n                _repr=float.__repr__, _inf=INFINITY, _neginf=-INFINITY):\n            # Check for specials.  Note that this type of test is processor\n            # and/or platform-specific, so do tests which don't depend on the\n            # internals.\n\n            if o != o:\n                text = 'NaN'\n            elif o == _inf:\n                text = 'Infinity'\n            elif o == _neginf:\n                text = '-Infinity'\n            else:\n                return _repr(o)\n\n            if not allow_nan:\n                raise ValueError(\n                    \"Out of range float values are not JSON compliant: \" +\n                    repr(o))\n\n            return text\n\n\n        if (_one_shot and c_make_encoder is not None\n                and self.indent is None):\n            _iterencode = c_make_encoder(\n                markers, self.default, _encoder, self.indent,\n                self.key_separator, self.item_separator, self.sort_keys,\n                self.skipkeys, self.allow_nan)\n        else:\n            _iterencode = _make_iterencode(\n                markers, self.default, _encoder, self.indent, floatstr,\n                self.key_separator, self.item_separator, self.sort_keys,\n                self.skipkeys, _one_shot)\n        return _iterencode(o, 0)\n\ndef _make_iterencode(markers, _default, _encoder, _indent, _floatstr,\n        _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot,\n        ## HACK: hand-optimized bytecode; turn globals into locals\n        ValueError=ValueError,\n        dict=dict,\n        float=float,\n        id=id,\n        int=int,\n        isinstance=isinstance,\n        list=list,\n        str=str,\n        tuple=tuple,\n        _intstr=int.__repr__,\n    ):\n\n    if _indent is not None and not isinstance(_indent, str):\n        _indent = ' ' * _indent\n\n    def _iterencode_list(lst, _current_indent_level):\n        if not lst:\n            yield '[]'\n            return\n        if markers is not None:\n            markerid = id(lst)\n            if markerid in markers:\n                raise ValueError(\"Circular reference detected\")\n            markers[markerid] = lst\n        buf = '['\n        if _indent is not None:\n            _current_indent_level += 1\n            newline_indent = '\\n' + _indent * _current_indent_level\n            separator = _item_separator + newline_indent\n            buf += newline_indent\n        else:\n            newline_indent = None\n            separator = _item_separator\n        first = True\n        for value in lst:\n            if first:\n                first = False\n            else:\n                buf = separator\n            if isinstance(value, str):\n                yield buf + _encoder(value)\n            elif value is None:\n                yield buf + 'null'\n            elif value is True:\n                yield buf + 'true'\n            elif value is False:\n                yield buf + 'false'\n            elif isinstance(value, int):\n                # Subclasses of int/float may override __repr__, but we still\n                # want to encode them as integers/floats in JSON. One example\n                # within the standard library is IntEnum.\n                yield buf + _intstr(value)\n            elif isinstance(value, float):\n                # see comment above for int\n                yield buf + _floatstr(value)\n            else:\n                yield buf\n                if isinstance(value, (list, tuple)):\n                    chunks = _iterencode_list(value, _current_indent_level)\n                elif isinstance(value, dict):\n                    chunks = _iterencode_dict(value, _current_indent_level)\n                else:\n                    chunks = _iterencode(value, _current_indent_level)\n                yield from chunks\n        if newline_indent is not None:\n            _current_indent_level -= 1\n            yield '\\n' + _indent * _current_indent_level\n        yield ']'\n        if markers is not None:\n            del markers[markerid]\n\n    def _iterencode_dict(dct, _current_indent_level):\n        if not dct:\n            yield '{}'\n            return\n        if markers is not None:\n            markerid = id(dct)\n            if markerid in markers:\n                raise ValueError(\"Circular reference detected\")\n            markers[markerid] = dct\n        yield '{'\n        if _indent is not None:\n            _current_indent_level += 1\n            newline_indent = '\\n' + _indent * _current_indent_level\n            item_separator = _item_separator + newline_indent\n            yield newline_indent\n        else:\n            newline_indent = None\n            item_separator = _item_separator\n        first = True\n        if _sort_keys:\n            items = sorted(dct.items())\n        else:\n            items = dct.items()\n        for key, value in items:\n            if isinstance(key, str):\n                pass\n            # JavaScript is weakly typed for these, so it makes sense to\n            # also allow them.  Many encoders seem to do something like this.\n            elif isinstance(key, float):\n                # see comment for int/float in _make_iterencode\n                key = _floatstr(key)\n            elif key is True:\n                key = 'true'\n            elif key is False:\n                key = 'false'\n            elif key is None:\n                key = 'null'\n            elif isinstance(key, int):\n                # see comment for int/float in _make_iterencode\n                key = _intstr(key)\n            elif _skipkeys:\n                continue\n            else:\n                raise TypeError(f'keys must be str, int, float, bool or None, '\n                                f'not {key.__class__.__name__}')\n            if first:\n                first = False\n            else:\n                yield item_separator\n            yield _encoder(key)\n            yield _key_separator\n            if isinstance(value, str):\n                yield _encoder(value)\n            elif value is None:\n                yield 'null'\n            elif value is True:\n                yield 'true'\n            elif value is False:\n                yield 'false'\n            elif isinstance(value, int):\n                # see comment for int/float in _make_iterencode\n                yield _intstr(value)\n            elif isinstance(value, float):\n                # see comment for int/float in _make_iterencode\n                yield _floatstr(value)\n            else:\n                if isinstance(value, (list, tuple)):\n                    chunks = _iterencode_list(value, _current_indent_level)\n                elif isinstance(value, dict):\n                    chunks = _iterencode_dict(value, _current_indent_level)\n                else:\n                    chunks = _iterencode(value, _current_indent_level)\n                yield from chunks\n        if newline_indent is not None:\n            _current_indent_level -= 1\n            yield '\\n' + _indent * _current_indent_level\n        yield '}'\n        if markers is not None:\n            del markers[markerid]\n\n    def _iterencode(o, _current_indent_level):\n        if isinstance(o, str):\n            yield _encoder(o)\n        elif o is None:\n            yield 'null'\n        elif o is True:\n            yield 'true'\n        elif o is False:\n            yield 'false'\n        elif isinstance(o, int):\n            # see comment for int/float in _make_iterencode\n            yield _intstr(o)\n        elif isinstance(o, float):\n            # see comment for int/float in _make_iterencode\n            yield _floatstr(o)\n        elif isinstance(o, (list, tuple)):\n            yield from _iterencode_list(o, _current_indent_level)\n        elif isinstance(o, dict):\n            yield from _iterencode_dict(o, _current_indent_level)\n        else:\n            if markers is not None:\n                markerid = id(o)\n                if markerid in markers:\n                    raise ValueError(\"Circular reference detected\")\n                markers[markerid] = o\n            o = _default(o)\n            yield from _iterencode(o, _current_indent_level)\n            if markers is not None:\n                del markers[markerid]\n    return _iterencode\n",
                443
            ],
            "C:\\Python\\Python311\\Lib\\encodings\\cp1252.py": [
                "\"\"\" Python Character Mapping Codec cp1252 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT' with gencodec.py.\n\n\"\"\"#\"\n\nimport codecs\n\n### Codec APIs\n\nclass Codec(codecs.Codec):\n\n    def encode(self,input,errors='strict'):\n        return codecs.charmap_encode(input,errors,encoding_table)\n\n    def decode(self,input,errors='strict'):\n        return codecs.charmap_decode(input,errors,decoding_table)\n\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return codecs.charmap_encode(input,self.errors,encoding_table)[0]\n\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return codecs.charmap_decode(input,self.errors,decoding_table)[0]\n\nclass StreamWriter(Codec,codecs.StreamWriter):\n    pass\n\nclass StreamReader(Codec,codecs.StreamReader):\n    pass\n\n### encodings module API\n\ndef getregentry():\n    return codecs.CodecInfo(\n        name='cp1252',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamreader=StreamReader,\n        streamwriter=StreamWriter,\n    )\n\n\n### Decoding Table\n\ndecoding_table = (\n    '\\x00'     #  0x00 -> NULL\n    '\\x01'     #  0x01 -> START OF HEADING\n    '\\x02'     #  0x02 -> START OF TEXT\n    '\\x03'     #  0x03 -> END OF TEXT\n    '\\x04'     #  0x04 -> END OF TRANSMISSION\n    '\\x05'     #  0x05 -> ENQUIRY\n    '\\x06'     #  0x06 -> ACKNOWLEDGE\n    '\\x07'     #  0x07 -> BELL\n    '\\x08'     #  0x08 -> BACKSPACE\n    '\\t'       #  0x09 -> HORIZONTAL TABULATION\n    '\\n'       #  0x0A -> LINE FEED\n    '\\x0b'     #  0x0B -> VERTICAL TABULATION\n    '\\x0c'     #  0x0C -> FORM FEED\n    '\\r'       #  0x0D -> CARRIAGE RETURN\n    '\\x0e'     #  0x0E -> SHIFT OUT\n    '\\x0f'     #  0x0F -> SHIFT IN\n    '\\x10'     #  0x10 -> DATA LINK ESCAPE\n    '\\x11'     #  0x11 -> DEVICE CONTROL ONE\n    '\\x12'     #  0x12 -> DEVICE CONTROL TWO\n    '\\x13'     #  0x13 -> DEVICE CONTROL THREE\n    '\\x14'     #  0x14 -> DEVICE CONTROL FOUR\n    '\\x15'     #  0x15 -> NEGATIVE ACKNOWLEDGE\n    '\\x16'     #  0x16 -> SYNCHRONOUS IDLE\n    '\\x17'     #  0x17 -> END OF TRANSMISSION BLOCK\n    '\\x18'     #  0x18 -> CANCEL\n    '\\x19'     #  0x19 -> END OF MEDIUM\n    '\\x1a'     #  0x1A -> SUBSTITUTE\n    '\\x1b'     #  0x1B -> ESCAPE\n    '\\x1c'     #  0x1C -> FILE SEPARATOR\n    '\\x1d'     #  0x1D -> GROUP SEPARATOR\n    '\\x1e'     #  0x1E -> RECORD SEPARATOR\n    '\\x1f'     #  0x1F -> UNIT SEPARATOR\n    ' '        #  0x20 -> SPACE\n    '!'        #  0x21 -> EXCLAMATION MARK\n    '\"'        #  0x22 -> QUOTATION MARK\n    '#'        #  0x23 -> NUMBER SIGN\n    '$'        #  0x24 -> DOLLAR SIGN\n    '%'        #  0x25 -> PERCENT SIGN\n    '&'        #  0x26 -> AMPERSAND\n    \"'\"        #  0x27 -> APOSTROPHE\n    '('        #  0x28 -> LEFT PARENTHESIS\n    ')'        #  0x29 -> RIGHT PARENTHESIS\n    '*'        #  0x2A -> ASTERISK\n    '+'        #  0x2B -> PLUS SIGN\n    ','        #  0x2C -> COMMA\n    '-'        #  0x2D -> HYPHEN-MINUS\n    '.'        #  0x2E -> FULL STOP\n    '/'        #  0x2F -> SOLIDUS\n    '0'        #  0x30 -> DIGIT ZERO\n    '1'        #  0x31 -> DIGIT ONE\n    '2'        #  0x32 -> DIGIT TWO\n    '3'        #  0x33 -> DIGIT THREE\n    '4'        #  0x34 -> DIGIT FOUR\n    '5'        #  0x35 -> DIGIT FIVE\n    '6'        #  0x36 -> DIGIT SIX\n    '7'        #  0x37 -> DIGIT SEVEN\n    '8'        #  0x38 -> DIGIT EIGHT\n    '9'        #  0x39 -> DIGIT NINE\n    ':'        #  0x3A -> COLON\n    ';'        #  0x3B -> SEMICOLON\n    '<'        #  0x3C -> LESS-THAN SIGN\n    '='        #  0x3D -> EQUALS SIGN\n    '>'        #  0x3E -> GREATER-THAN SIGN\n    '?'        #  0x3F -> QUESTION MARK\n    '@'        #  0x40 -> COMMERCIAL AT\n    'A'        #  0x41 -> LATIN CAPITAL LETTER A\n    'B'        #  0x42 -> LATIN CAPITAL LETTER B\n    'C'        #  0x43 -> LATIN CAPITAL LETTER C\n    'D'        #  0x44 -> LATIN CAPITAL LETTER D\n    'E'        #  0x45 -> LATIN CAPITAL LETTER E\n    'F'        #  0x46 -> LATIN CAPITAL LETTER F\n    'G'        #  0x47 -> LATIN CAPITAL LETTER G\n    'H'        #  0x48 -> LATIN CAPITAL LETTER H\n    'I'        #  0x49 -> LATIN CAPITAL LETTER I\n    'J'        #  0x4A -> LATIN CAPITAL LETTER J\n    'K'        #  0x4B -> LATIN CAPITAL LETTER K\n    'L'        #  0x4C -> LATIN CAPITAL LETTER L\n    'M'        #  0x4D -> LATIN CAPITAL LETTER M\n    'N'        #  0x4E -> LATIN CAPITAL LETTER N\n    'O'        #  0x4F -> LATIN CAPITAL LETTER O\n    'P'        #  0x50 -> LATIN CAPITAL LETTER P\n    'Q'        #  0x51 -> LATIN CAPITAL LETTER Q\n    'R'        #  0x52 -> LATIN CAPITAL LETTER R\n    'S'        #  0x53 -> LATIN CAPITAL LETTER S\n    'T'        #  0x54 -> LATIN CAPITAL LETTER T\n    'U'        #  0x55 -> LATIN CAPITAL LETTER U\n    'V'        #  0x56 -> LATIN CAPITAL LETTER V\n    'W'        #  0x57 -> LATIN CAPITAL LETTER W\n    'X'        #  0x58 -> LATIN CAPITAL LETTER X\n    'Y'        #  0x59 -> LATIN CAPITAL LETTER Y\n    'Z'        #  0x5A -> LATIN CAPITAL LETTER Z\n    '['        #  0x5B -> LEFT SQUARE BRACKET\n    '\\\\'       #  0x5C -> REVERSE SOLIDUS\n    ']'        #  0x5D -> RIGHT SQUARE BRACKET\n    '^'        #  0x5E -> CIRCUMFLEX ACCENT\n    '_'        #  0x5F -> LOW LINE\n    '`'        #  0x60 -> GRAVE ACCENT\n    'a'        #  0x61 -> LATIN SMALL LETTER A\n    'b'        #  0x62 -> LATIN SMALL LETTER B\n    'c'        #  0x63 -> LATIN SMALL LETTER C\n    'd'        #  0x64 -> LATIN SMALL LETTER D\n    'e'        #  0x65 -> LATIN SMALL LETTER E\n    'f'        #  0x66 -> LATIN SMALL LETTER F\n    'g'        #  0x67 -> LATIN SMALL LETTER G\n    'h'        #  0x68 -> LATIN SMALL LETTER H\n    'i'        #  0x69 -> LATIN SMALL LETTER I\n    'j'        #  0x6A -> LATIN SMALL LETTER J\n    'k'        #  0x6B -> LATIN SMALL LETTER K\n    'l'        #  0x6C -> LATIN SMALL LETTER L\n    'm'        #  0x6D -> LATIN SMALL LETTER M\n    'n'        #  0x6E -> LATIN SMALL LETTER N\n    'o'        #  0x6F -> LATIN SMALL LETTER O\n    'p'        #  0x70 -> LATIN SMALL LETTER P\n    'q'        #  0x71 -> LATIN SMALL LETTER Q\n    'r'        #  0x72 -> LATIN SMALL LETTER R\n    's'        #  0x73 -> LATIN SMALL LETTER S\n    't'        #  0x74 -> LATIN SMALL LETTER T\n    'u'        #  0x75 -> LATIN SMALL LETTER U\n    'v'        #  0x76 -> LATIN SMALL LETTER V\n    'w'        #  0x77 -> LATIN SMALL LETTER W\n    'x'        #  0x78 -> LATIN SMALL LETTER X\n    'y'        #  0x79 -> LATIN SMALL LETTER Y\n    'z'        #  0x7A -> LATIN SMALL LETTER Z\n    '{'        #  0x7B -> LEFT CURLY BRACKET\n    '|'        #  0x7C -> VERTICAL LINE\n    '}'        #  0x7D -> RIGHT CURLY BRACKET\n    '~'        #  0x7E -> TILDE\n    '\\x7f'     #  0x7F -> DELETE\n    '\\u20ac'   #  0x80 -> EURO SIGN\n    '\\ufffe'   #  0x81 -> UNDEFINED\n    '\\u201a'   #  0x82 -> SINGLE LOW-9 QUOTATION MARK\n    '\\u0192'   #  0x83 -> LATIN SMALL LETTER F WITH HOOK\n    '\\u201e'   #  0x84 -> DOUBLE LOW-9 QUOTATION MARK\n    '\\u2026'   #  0x85 -> HORIZONTAL ELLIPSIS\n    '\\u2020'   #  0x86 -> DAGGER\n    '\\u2021'   #  0x87 -> DOUBLE DAGGER\n    '\\u02c6'   #  0x88 -> MODIFIER LETTER CIRCUMFLEX ACCENT\n    '\\u2030'   #  0x89 -> PER MILLE SIGN\n    '\\u0160'   #  0x8A -> LATIN CAPITAL LETTER S WITH CARON\n    '\\u2039'   #  0x8B -> SINGLE LEFT-POINTING ANGLE QUOTATION MARK\n    '\\u0152'   #  0x8C -> LATIN CAPITAL LIGATURE OE\n    '\\ufffe'   #  0x8D -> UNDEFINED\n    '\\u017d'   #  0x8E -> LATIN CAPITAL LETTER Z WITH CARON\n    '\\ufffe'   #  0x8F -> UNDEFINED\n    '\\ufffe'   #  0x90 -> UNDEFINED\n    '\\u2018'   #  0x91 -> LEFT SINGLE QUOTATION MARK\n    '\\u2019'   #  0x92 -> RIGHT SINGLE QUOTATION MARK\n    '\\u201c'   #  0x93 -> LEFT DOUBLE QUOTATION MARK\n    '\\u201d'   #  0x94 -> RIGHT DOUBLE QUOTATION MARK\n    '\\u2022'   #  0x95 -> BULLET\n    '\\u2013'   #  0x96 -> EN DASH\n    '\\u2014'   #  0x97 -> EM DASH\n    '\\u02dc'   #  0x98 -> SMALL TILDE\n    '\\u2122'   #  0x99 -> TRADE MARK SIGN\n    '\\u0161'   #  0x9A -> LATIN SMALL LETTER S WITH CARON\n    '\\u203a'   #  0x9B -> SINGLE RIGHT-POINTING ANGLE QUOTATION MARK\n    '\\u0153'   #  0x9C -> LATIN SMALL LIGATURE OE\n    '\\ufffe'   #  0x9D -> UNDEFINED\n    '\\u017e'   #  0x9E -> LATIN SMALL LETTER Z WITH CARON\n    '\\u0178'   #  0x9F -> LATIN CAPITAL LETTER Y WITH DIAERESIS\n    '\\xa0'     #  0xA0 -> NO-BREAK SPACE\n    '\\xa1'     #  0xA1 -> INVERTED EXCLAMATION MARK\n    '\\xa2'     #  0xA2 -> CENT SIGN\n    '\\xa3'     #  0xA3 -> POUND SIGN\n    '\\xa4'     #  0xA4 -> CURRENCY SIGN\n    '\\xa5'     #  0xA5 -> YEN SIGN\n    '\\xa6'     #  0xA6 -> BROKEN BAR\n    '\\xa7'     #  0xA7 -> SECTION SIGN\n    '\\xa8'     #  0xA8 -> DIAERESIS\n    '\\xa9'     #  0xA9 -> COPYRIGHT SIGN\n    '\\xaa'     #  0xAA -> FEMININE ORDINAL INDICATOR\n    '\\xab'     #  0xAB -> LEFT-POINTING DOUBLE ANGLE QUOTATION MARK\n    '\\xac'     #  0xAC -> NOT SIGN\n    '\\xad'     #  0xAD -> SOFT HYPHEN\n    '\\xae'     #  0xAE -> REGISTERED SIGN\n    '\\xaf'     #  0xAF -> MACRON\n    '\\xb0'     #  0xB0 -> DEGREE SIGN\n    '\\xb1'     #  0xB1 -> PLUS-MINUS SIGN\n    '\\xb2'     #  0xB2 -> SUPERSCRIPT TWO\n    '\\xb3'     #  0xB3 -> SUPERSCRIPT THREE\n    '\\xb4'     #  0xB4 -> ACUTE ACCENT\n    '\\xb5'     #  0xB5 -> MICRO SIGN\n    '\\xb6'     #  0xB6 -> PILCROW SIGN\n    '\\xb7'     #  0xB7 -> MIDDLE DOT\n    '\\xb8'     #  0xB8 -> CEDILLA\n    '\\xb9'     #  0xB9 -> SUPERSCRIPT ONE\n    '\\xba'     #  0xBA -> MASCULINE ORDINAL INDICATOR\n    '\\xbb'     #  0xBB -> RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\n    '\\xbc'     #  0xBC -> VULGAR FRACTION ONE QUARTER\n    '\\xbd'     #  0xBD -> VULGAR FRACTION ONE HALF\n    '\\xbe'     #  0xBE -> VULGAR FRACTION THREE QUARTERS\n    '\\xbf'     #  0xBF -> INVERTED QUESTION MARK\n    '\\xc0'     #  0xC0 -> LATIN CAPITAL LETTER A WITH GRAVE\n    '\\xc1'     #  0xC1 -> LATIN CAPITAL LETTER A WITH ACUTE\n    '\\xc2'     #  0xC2 -> LATIN CAPITAL LETTER A WITH CIRCUMFLEX\n    '\\xc3'     #  0xC3 -> LATIN CAPITAL LETTER A WITH TILDE\n    '\\xc4'     #  0xC4 -> LATIN CAPITAL LETTER A WITH DIAERESIS\n    '\\xc5'     #  0xC5 -> LATIN CAPITAL LETTER A WITH RING ABOVE\n    '\\xc6'     #  0xC6 -> LATIN CAPITAL LETTER AE\n    '\\xc7'     #  0xC7 -> LATIN CAPITAL LETTER C WITH CEDILLA\n    '\\xc8'     #  0xC8 -> LATIN CAPITAL LETTER E WITH GRAVE\n    '\\xc9'     #  0xC9 -> LATIN CAPITAL LETTER E WITH ACUTE\n    '\\xca'     #  0xCA -> LATIN CAPITAL LETTER E WITH CIRCUMFLEX\n    '\\xcb'     #  0xCB -> LATIN CAPITAL LETTER E WITH DIAERESIS\n    '\\xcc'     #  0xCC -> LATIN CAPITAL LETTER I WITH GRAVE\n    '\\xcd'     #  0xCD -> LATIN CAPITAL LETTER I WITH ACUTE\n    '\\xce'     #  0xCE -> LATIN CAPITAL LETTER I WITH CIRCUMFLEX\n    '\\xcf'     #  0xCF -> LATIN CAPITAL LETTER I WITH DIAERESIS\n    '\\xd0'     #  0xD0 -> LATIN CAPITAL LETTER ETH\n    '\\xd1'     #  0xD1 -> LATIN CAPITAL LETTER N WITH TILDE\n    '\\xd2'     #  0xD2 -> LATIN CAPITAL LETTER O WITH GRAVE\n    '\\xd3'     #  0xD3 -> LATIN CAPITAL LETTER O WITH ACUTE\n    '\\xd4'     #  0xD4 -> LATIN CAPITAL LETTER O WITH CIRCUMFLEX\n    '\\xd5'     #  0xD5 -> LATIN CAPITAL LETTER O WITH TILDE\n    '\\xd6'     #  0xD6 -> LATIN CAPITAL LETTER O WITH DIAERESIS\n    '\\xd7'     #  0xD7 -> MULTIPLICATION SIGN\n    '\\xd8'     #  0xD8 -> LATIN CAPITAL LETTER O WITH STROKE\n    '\\xd9'     #  0xD9 -> LATIN CAPITAL LETTER U WITH GRAVE\n    '\\xda'     #  0xDA -> LATIN CAPITAL LETTER U WITH ACUTE\n    '\\xdb'     #  0xDB -> LATIN CAPITAL LETTER U WITH CIRCUMFLEX\n    '\\xdc'     #  0xDC -> LATIN CAPITAL LETTER U WITH DIAERESIS\n    '\\xdd'     #  0xDD -> LATIN CAPITAL LETTER Y WITH ACUTE\n    '\\xde'     #  0xDE -> LATIN CAPITAL LETTER THORN\n    '\\xdf'     #  0xDF -> LATIN SMALL LETTER SHARP S\n    '\\xe0'     #  0xE0 -> LATIN SMALL LETTER A WITH GRAVE\n    '\\xe1'     #  0xE1 -> LATIN SMALL LETTER A WITH ACUTE\n    '\\xe2'     #  0xE2 -> LATIN SMALL LETTER A WITH CIRCUMFLEX\n    '\\xe3'     #  0xE3 -> LATIN SMALL LETTER A WITH TILDE\n    '\\xe4'     #  0xE4 -> LATIN SMALL LETTER A WITH DIAERESIS\n    '\\xe5'     #  0xE5 -> LATIN SMALL LETTER A WITH RING ABOVE\n    '\\xe6'     #  0xE6 -> LATIN SMALL LETTER AE\n    '\\xe7'     #  0xE7 -> LATIN SMALL LETTER C WITH CEDILLA\n    '\\xe8'     #  0xE8 -> LATIN SMALL LETTER E WITH GRAVE\n    '\\xe9'     #  0xE9 -> LATIN SMALL LETTER E WITH ACUTE\n    '\\xea'     #  0xEA -> LATIN SMALL LETTER E WITH CIRCUMFLEX\n    '\\xeb'     #  0xEB -> LATIN SMALL LETTER E WITH DIAERESIS\n    '\\xec'     #  0xEC -> LATIN SMALL LETTER I WITH GRAVE\n    '\\xed'     #  0xED -> LATIN SMALL LETTER I WITH ACUTE\n    '\\xee'     #  0xEE -> LATIN SMALL LETTER I WITH CIRCUMFLEX\n    '\\xef'     #  0xEF -> LATIN SMALL LETTER I WITH DIAERESIS\n    '\\xf0'     #  0xF0 -> LATIN SMALL LETTER ETH\n    '\\xf1'     #  0xF1 -> LATIN SMALL LETTER N WITH TILDE\n    '\\xf2'     #  0xF2 -> LATIN SMALL LETTER O WITH GRAVE\n    '\\xf3'     #  0xF3 -> LATIN SMALL LETTER O WITH ACUTE\n    '\\xf4'     #  0xF4 -> LATIN SMALL LETTER O WITH CIRCUMFLEX\n    '\\xf5'     #  0xF5 -> LATIN SMALL LETTER O WITH TILDE\n    '\\xf6'     #  0xF6 -> LATIN SMALL LETTER O WITH DIAERESIS\n    '\\xf7'     #  0xF7 -> DIVISION SIGN\n    '\\xf8'     #  0xF8 -> LATIN SMALL LETTER O WITH STROKE\n    '\\xf9'     #  0xF9 -> LATIN SMALL LETTER U WITH GRAVE\n    '\\xfa'     #  0xFA -> LATIN SMALL LETTER U WITH ACUTE\n    '\\xfb'     #  0xFB -> LATIN SMALL LETTER U WITH CIRCUMFLEX\n    '\\xfc'     #  0xFC -> LATIN SMALL LETTER U WITH DIAERESIS\n    '\\xfd'     #  0xFD -> LATIN SMALL LETTER Y WITH ACUTE\n    '\\xfe'     #  0xFE -> LATIN SMALL LETTER THORN\n    '\\xff'     #  0xFF -> LATIN SMALL LETTER Y WITH DIAERESIS\n)\n\n### Encoding table\nencoding_table=codecs.charmap_build(decoding_table)\n",
                307
            ],
            "C:\\Python\\Python311\\Lib\\json\\__init__.py": [
                "r\"\"\"JSON (JavaScript Object Notation) <https://json.org> is a subset of\nJavaScript syntax (ECMA-262 3rd edition) used as a lightweight data\ninterchange format.\n\n:mod:`json` exposes an API familiar to users of the standard library\n:mod:`marshal` and :mod:`pickle` modules.  It is derived from a\nversion of the externally maintained simplejson library.\n\nEncoding basic Python object hierarchies::\n\n    >>> import json\n    >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n    '[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n    >>> print(json.dumps(\"\\\"foo\\bar\"))\n    \"\\\"foo\\bar\"\n    >>> print(json.dumps('\\u1234'))\n    \"\\u1234\"\n    >>> print(json.dumps('\\\\'))\n    \"\\\\\"\n    >>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n    {\"a\": 0, \"b\": 0, \"c\": 0}\n    >>> from io import StringIO\n    >>> io = StringIO()\n    >>> json.dump(['streaming API'], io)\n    >>> io.getvalue()\n    '[\"streaming API\"]'\n\nCompact encoding::\n\n    >>> import json\n    >>> mydict = {'4': 5, '6': 7}\n    >>> json.dumps([1,2,3,mydict], separators=(',', ':'))\n    '[1,2,3,{\"4\":5,\"6\":7}]'\n\nPretty printing::\n\n    >>> import json\n    >>> print(json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4))\n    {\n        \"4\": 5,\n        \"6\": 7\n    }\n\nDecoding JSON::\n\n    >>> import json\n    >>> obj = ['foo', {'bar': ['baz', None, 1.0, 2]}]\n    >>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]') == obj\n    True\n    >>> json.loads('\"\\\\\"foo\\\\bar\"') == '\"foo\\x08ar'\n    True\n    >>> from io import StringIO\n    >>> io = StringIO('[\"streaming API\"]')\n    >>> json.load(io)[0] == 'streaming API'\n    True\n\nSpecializing JSON object decoding::\n\n    >>> import json\n    >>> def as_complex(dct):\n    ...     if '__complex__' in dct:\n    ...         return complex(dct['real'], dct['imag'])\n    ...     return dct\n    ...\n    >>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n    ...     object_hook=as_complex)\n    (1+2j)\n    >>> from decimal import Decimal\n    >>> json.loads('1.1', parse_float=Decimal) == Decimal('1.1')\n    True\n\nSpecializing JSON object encoding::\n\n    >>> import json\n    >>> def encode_complex(obj):\n    ...     if isinstance(obj, complex):\n    ...         return [obj.real, obj.imag]\n    ...     raise TypeError(f'Object of type {obj.__class__.__name__} '\n    ...                     f'is not JSON serializable')\n    ...\n    >>> json.dumps(2 + 1j, default=encode_complex)\n    '[2.0, 1.0]'\n    >>> json.JSONEncoder(default=encode_complex).encode(2 + 1j)\n    '[2.0, 1.0]'\n    >>> ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))\n    '[2.0, 1.0]'\n\n\nUsing json.tool from the shell to validate and pretty-print::\n\n    $ echo '{\"json\":\"obj\"}' | python -m json.tool\n    {\n        \"json\": \"obj\"\n    }\n    $ echo '{ 1.2:3.4}' | python -m json.tool\n    Expecting property name enclosed in double quotes: line 1 column 3 (char 2)\n\"\"\"\n__version__ = '2.0.9'\n__all__ = [\n    'dump', 'dumps', 'load', 'loads',\n    'JSONDecoder', 'JSONDecodeError', 'JSONEncoder',\n]\n\n__author__ = 'Bob Ippolito <bob@redivi.com>'\n\nfrom .decoder import JSONDecoder, JSONDecodeError\nfrom .encoder import JSONEncoder\nimport codecs\n\n_default_encoder = JSONEncoder(\n    skipkeys=False,\n    ensure_ascii=True,\n    check_circular=True,\n    allow_nan=True,\n    indent=None,\n    separators=None,\n    default=None,\n)\n\ndef dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True,\n        allow_nan=True, cls=None, indent=None, separators=None,\n        default=None, sort_keys=False, **kw):\n    \"\"\"Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n    ``.write()``-supporting file-like object).\n\n    If ``skipkeys`` is true then ``dict`` keys that are not basic types\n    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped\n    instead of raising a ``TypeError``.\n\n    If ``ensure_ascii`` is false, then the strings written to ``fp`` can\n    contain non-ASCII characters if they appear in strings contained in\n    ``obj``. Otherwise, all such characters are escaped in JSON strings.\n\n    If ``check_circular`` is false, then the circular reference check\n    for container types will be skipped and a circular reference will\n    result in an ``RecursionError`` (or worse).\n\n    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)\n    in strict compliance of the JSON specification, instead of using the\n    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\n    If ``indent`` is a non-negative integer, then JSON array elements and\n    object members will be pretty-printed with that indent level. An indent\n    level of 0 will only insert newlines. ``None`` is the most compact\n    representation.\n\n    If specified, ``separators`` should be an ``(item_separator, key_separator)``\n    tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and\n    ``(',', ': ')`` otherwise.  To get the most compact JSON representation,\n    you should specify ``(',', ':')`` to eliminate whitespace.\n\n    ``default(obj)`` is a function that should return a serializable version\n    of obj or raise TypeError. The default simply raises TypeError.\n\n    If *sort_keys* is true (default: ``False``), then the output of\n    dictionaries will be sorted by key.\n\n    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n    ``.default()`` method to serialize additional types), specify it with\n    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.\n\n    \"\"\"\n    # cached encoder\n    if (not skipkeys and ensure_ascii and\n        check_circular and allow_nan and\n        cls is None and indent is None and separators is None and\n        default is None and not sort_keys and not kw):\n        iterable = _default_encoder.iterencode(obj)\n    else:\n        if cls is None:\n            cls = JSONEncoder\n        iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,\n            check_circular=check_circular, allow_nan=allow_nan, indent=indent,\n            separators=separators,\n            default=default, sort_keys=sort_keys, **kw).iterencode(obj)\n    # could accelerate with writelines in some versions of Python, at\n    # a debuggability cost\n    for chunk in iterable:\n        fp.write(chunk)\n\n\ndef dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True,\n        allow_nan=True, cls=None, indent=None, separators=None,\n        default=None, sort_keys=False, **kw):\n    \"\"\"Serialize ``obj`` to a JSON formatted ``str``.\n\n    If ``skipkeys`` is true then ``dict`` keys that are not basic types\n    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped\n    instead of raising a ``TypeError``.\n\n    If ``ensure_ascii`` is false, then the return value can contain non-ASCII\n    characters if they appear in strings contained in ``obj``. Otherwise, all\n    such characters are escaped in JSON strings.\n\n    If ``check_circular`` is false, then the circular reference check\n    for container types will be skipped and a circular reference will\n    result in an ``RecursionError`` (or worse).\n\n    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in\n    strict compliance of the JSON specification, instead of using the\n    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\n    If ``indent`` is a non-negative integer, then JSON array elements and\n    object members will be pretty-printed with that indent level. An indent\n    level of 0 will only insert newlines. ``None`` is the most compact\n    representation.\n\n    If specified, ``separators`` should be an ``(item_separator, key_separator)``\n    tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and\n    ``(',', ': ')`` otherwise.  To get the most compact JSON representation,\n    you should specify ``(',', ':')`` to eliminate whitespace.\n\n    ``default(obj)`` is a function that should return a serializable version\n    of obj or raise TypeError. The default simply raises TypeError.\n\n    If *sort_keys* is true (default: ``False``), then the output of\n    dictionaries will be sorted by key.\n\n    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n    ``.default()`` method to serialize additional types), specify it with\n    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.\n\n    \"\"\"\n    # cached encoder\n    if (not skipkeys and ensure_ascii and\n        check_circular and allow_nan and\n        cls is None and indent is None and separators is None and\n        default is None and not sort_keys and not kw):\n        return _default_encoder.encode(obj)\n    if cls is None:\n        cls = JSONEncoder\n    return cls(\n        skipkeys=skipkeys, ensure_ascii=ensure_ascii,\n        check_circular=check_circular, allow_nan=allow_nan, indent=indent,\n        separators=separators, default=default, sort_keys=sort_keys,\n        **kw).encode(obj)\n\n\n_default_decoder = JSONDecoder(object_hook=None, object_pairs_hook=None)\n\n\ndef detect_encoding(b):\n    bstartswith = b.startswith\n    if bstartswith((codecs.BOM_UTF32_BE, codecs.BOM_UTF32_LE)):\n        return 'utf-32'\n    if bstartswith((codecs.BOM_UTF16_BE, codecs.BOM_UTF16_LE)):\n        return 'utf-16'\n    if bstartswith(codecs.BOM_UTF8):\n        return 'utf-8-sig'\n\n    if len(b) >= 4:\n        if not b[0]:\n            # 00 00 -- -- - utf-32-be\n            # 00 XX -- -- - utf-16-be\n            return 'utf-16-be' if b[1] else 'utf-32-be'\n        if not b[1]:\n            # XX 00 00 00 - utf-32-le\n            # XX 00 00 XX - utf-16-le\n            # XX 00 XX -- - utf-16-le\n            return 'utf-16-le' if b[2] or b[3] else 'utf-32-le'\n    elif len(b) == 2:\n        if not b[0]:\n            # 00 XX - utf-16-be\n            return 'utf-16-be'\n        if not b[1]:\n            # XX 00 - utf-16-le\n            return 'utf-16-le'\n    # default\n    return 'utf-8'\n\n\ndef load(fp, *, cls=None, object_hook=None, parse_float=None,\n        parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):\n    \"\"\"Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\n    a JSON document) to a Python object.\n\n    ``object_hook`` is an optional function that will be called with the\n    result of any object literal decode (a ``dict``). The return value of\n    ``object_hook`` will be used instead of the ``dict``. This feature\n    can be used to implement custom decoders (e.g. JSON-RPC class hinting).\n\n    ``object_pairs_hook`` is an optional function that will be called with the\n    result of any object literal decoded with an ordered list of pairs.  The\n    return value of ``object_pairs_hook`` will be used instead of the ``dict``.\n    This feature can be used to implement custom decoders.  If ``object_hook``\n    is also defined, the ``object_pairs_hook`` takes priority.\n\n    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n    kwarg; otherwise ``JSONDecoder`` is used.\n    \"\"\"\n    return loads(fp.read(),\n        cls=cls, object_hook=object_hook,\n        parse_float=parse_float, parse_int=parse_int,\n        parse_constant=parse_constant, object_pairs_hook=object_pairs_hook, **kw)\n\n\ndef loads(s, *, cls=None, object_hook=None, parse_float=None,\n        parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):\n    \"\"\"Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\n    containing a JSON document) to a Python object.\n\n    ``object_hook`` is an optional function that will be called with the\n    result of any object literal decode (a ``dict``). The return value of\n    ``object_hook`` will be used instead of the ``dict``. This feature\n    can be used to implement custom decoders (e.g. JSON-RPC class hinting).\n\n    ``object_pairs_hook`` is an optional function that will be called with the\n    result of any object literal decoded with an ordered list of pairs.  The\n    return value of ``object_pairs_hook`` will be used instead of the ``dict``.\n    This feature can be used to implement custom decoders.  If ``object_hook``\n    is also defined, the ``object_pairs_hook`` takes priority.\n\n    ``parse_float``, if specified, will be called with the string\n    of every JSON float to be decoded. By default this is equivalent to\n    float(num_str). This can be used to use another datatype or parser\n    for JSON floats (e.g. decimal.Decimal).\n\n    ``parse_int``, if specified, will be called with the string\n    of every JSON int to be decoded. By default this is equivalent to\n    int(num_str). This can be used to use another datatype or parser\n    for JSON integers (e.g. float).\n\n    ``parse_constant``, if specified, will be called with one of the\n    following strings: -Infinity, Infinity, NaN.\n    This can be used to raise an exception if invalid JSON numbers\n    are encountered.\n\n    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n    kwarg; otherwise ``JSONDecoder`` is used.\n    \"\"\"\n    if isinstance(s, str):\n        if s.startswith('\\ufeff'):\n            raise JSONDecodeError(\"Unexpected UTF-8 BOM (decode using utf-8-sig)\",\n                                  s, 0)\n    else:\n        if not isinstance(s, (bytes, bytearray)):\n            raise TypeError(f'the JSON object must be str, bytes or bytearray, '\n                            f'not {s.__class__.__name__}')\n        s = s.decode(detect_encoding(s), 'surrogatepass')\n\n    if (cls is None and object_hook is None and\n            parse_int is None and parse_float is None and\n            parse_constant is None and object_pairs_hook is None and not kw):\n        return _default_decoder.decode(s)\n    if cls is None:\n        cls = JSONDecoder\n    if object_hook is not None:\n        kw['object_hook'] = object_hook\n    if object_pairs_hook is not None:\n        kw['object_pairs_hook'] = object_pairs_hook\n    if parse_float is not None:\n        kw['parse_float'] = parse_float\n    if parse_int is not None:\n        kw['parse_int'] = parse_int\n    if parse_constant is not None:\n        kw['parse_constant'] = parse_constant\n    return cls(**kw).decode(s)\n",
                359
            ]
        },
        "functions": {
            "is_prime (C:\\Users\\tomtz\\dev\\branes\\clones\\graphs\\tools\\chrome-tracer\\prime_numbers.py:23)": [
                "C:\\Users\\tomtz\\dev\\branes\\clones\\graphs\\tools\\chrome-tracer\\prime_numbers.py",
                23
            ],
            "find_primes (C:\\Users\\tomtz\\dev\\branes\\clones\\graphs\\tools\\chrome-tracer\\prime_numbers.py:44)": [
                "C:\\Users\\tomtz\\dev\\branes\\clones\\graphs\\tools\\chrome-tracer\\prime_numbers.py",
                44
            ],
            "IncrementalEncoder.__init__ (<frozen codecs>:186)": [
                "<frozen codecs>",
                186
            ],
            "JSONEncoder.__init__ (C:\\Python\\Python311\\Lib\\json\\encoder.py:105)": [
                "C:\\Python\\Python311\\Lib\\json\\encoder.py",
                105
            ],
            "_make_iterencode (C:\\Python\\Python311\\Lib\\json\\encoder.py:260)": [
                "C:\\Python\\Python311\\Lib\\json\\encoder.py",
                260
            ],
            "JSONEncoder.iterencode (C:\\Python\\Python311\\Lib\\json\\encoder.py:205)": [
                "C:\\Python\\Python311\\Lib\\json\\encoder.py",
                205
            ],
            "_make_iterencode.<locals>._iterencode_dict (C:\\Python\\Python311\\Lib\\json\\encoder.py:334)": [
                "C:\\Python\\Python311\\Lib\\json\\encoder.py",
                334
            ],
            "_make_iterencode.<locals>._iterencode (C:\\Python\\Python311\\Lib\\json\\encoder.py:414)": [
                "C:\\Python\\Python311\\Lib\\json\\encoder.py",
                414
            ],
            "IncrementalEncoder.encode (C:\\Python\\Python311\\Lib\\encodings\\cp1252.py:18)": [
                "C:\\Python\\Python311\\Lib\\encodings\\cp1252.py",
                18
            ],
            "JSONEncoder.iterencode.<locals>.floatstr (C:\\Python\\Python311\\Lib\\json\\encoder.py:224)": [
                "C:\\Python\\Python311\\Lib\\json\\encoder.py",
                224
            ],
            "_make_iterencode.<locals>._iterencode_list (C:\\Python\\Python311\\Lib\\json\\encoder.py:278)": [
                "C:\\Python\\Python311\\Lib\\json\\encoder.py",
                278
            ],
            "dump (C:\\Python\\Python311\\Lib\\json\\__init__.py:120)": [
                "C:\\Python\\Python311\\Lib\\json\\__init__.py",
                120
            ],
            "write_viztracker_json (C:\\Users\\tomtz\\dev\\branes\\clones\\graphs\\tools\\chrome-tracer\\prime_numbers.py:6)": [
                "C:\\Users\\tomtz\\dev\\branes\\clones\\graphs\\tools\\chrome-tracer\\prime_numbers.py",
                6
            ],
            "<module> (C:\\Users\\tomtz\\dev\\branes\\clones\\graphs\\tools\\chrome-tracer\\prime_numbers.py:1)": [
                "C:\\Users\\tomtz\\dev\\branes\\clones\\graphs\\tools\\chrome-tracer\\prime_numbers.py",
                1
            ]
        }
    }
}
import torch
from ultralytics import YOLO

# 1. Load your YOLO model
model = YOLO('yolov8n.pt').model.eval()

# 2. Define a function to compile with TorchDynamo
# TorchDynamo will generate an FX graph internally
def compile_fn(model, inputs):
    return model(inputs)

# Create a dummy input
dummy_input = torch.randn(1, 3, 640, 640)

# 3. Use torch.compile with a backend that generates an FX graph
# 'aot_eager' is a good choice for graph inspection, or 'inductor' for speed
# You can often inspect the graph generated by TorchDynamo

# This line will run the tracing (compilation)
compiled_model = torch.compile(model, backend="aot_eager")

# Run the compiled model once for tracing
output = compiled_model(dummy_input)

print("YOLO model successfully traced/compiled using TorchDynamo.")
# Note: Retrieving the raw FX graph from torch.compile can be complex,
# but the model is now optimized and effectively traced.

for node in compiled_model.graph.nodes:
    print(node)



"""
The error AttributeError: 'DetectionModel' object has no attribute 
'graph' occurs because the object returned by torch.compile 
(compiled_model) is a wrapper, and it doesn't expose the FX graph 
directly via a .graph attribute like a standard torch.fx.GraphModule does.

To access and enumerate the FX graph generated by TorchDynamo (torch.compile), 
you need to use a specific backend or a utility function designed to 
extract the graph from the compiled model.

The most straightforward way is to use the torch._dynamo.export 
utility or a custom backend hook. Since you're using the aot_eager 
backend, the easiest method for inspection is using the 
recompile_failure hook, but the clean method is using torch._dynamo.export.

see yolo8nano.py for an example of how to do this.
"""